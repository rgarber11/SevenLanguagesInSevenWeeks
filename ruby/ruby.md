# Ruby 
----------
## Day 1 
Most of these were pretty easy, and similar to their equals in langauges like Python. One interesting thing is the fact that the standard `a..b` range is inclusive, unlike in Python and C++ where [a,b) is the standard. `a...b` gives the uninclusive range. 
For the game. I decided to go a bit further, allowing to set the upper and lower bounds. `loop do` is also a feature that I'm used to in Rust, and allows for a simple infinite loop.
## Day 2 
Finally, something a bit more interesting! Code blocks as anonymous functions seem so cool, and really a feature that made this section worth it.
* While `each_slice` is certainly more user friendly than `each` in this case, I really like the composability of `with_index`. While it certainly compares to Python's `enumerate()`, the fact that Ruby lets you leave off parentheses really simplifies the syntax, and looks nicer.
* I chose to solve this with class functions, maintaining the original initializer. As such, I used two functions. One of these is only used for children, so I read online how to make it private. One of the issues I find with older dynamic languages is the proliferation of different ways to do similar things (Though as a C++ developer, I feel a bit hypocritical) `private_class_method` and `class << self` along with `private` made me feel a bit bad. However, I'm nitpicking, and I think this solution is still very nice.
* The first grep I think really shows the power of blocks, and the beauty of the Ruby File API. `ARGV[0]` is weird to me. In all languages that I've used, that would be the name of the program, not the first command-line argument. Not too bad of a change though.\
The problem with this grep, however, is that most people have binary files in their folders, which will cause an argument error. I could have solved this with a `begin...rescue...end`, but I also decided to use [ruby-filemagic](https://github.com/blackwinter/ruby-filemagic) to select for only text files. This makes this grep actually usable (even if a recursive option would be needed for me.)
## Day 3
Generically, I'd say that metaprogramming is a scary thing. My limited uses of it have made me feel that it can be very brittle, even if using it within its confines is nice. However, I do really like most of Ruby's metaprogramming abilities (Even if I'm not personally sure that I'd call them that). For one, I think Open Classes are really logical for dynamic programming languages. If you can attach new methods and parameters, why taking it a step further and allowing redefinition of class methods isn't done in other places is beyond me. `method_missing` is a little scarier however. While really cool, it seems like inheritance doesn't interact well with it per [this article](https://josh-works.medium.com/metaprogramming-in-ruby-method-missing-f6d7f7f6aef5). I would imagine that modules interact better with it, as they're included rather than inherited, but that still makes me more hesitant to use them. Modules are very fun (even if the ClassMethod InstanceMethod stuff feels a bit odd) and probably would be my preferred form of code reuse if I were a Ruby developer.\
Adding `CsvRow` wasn't too bad. It needed to have a copy of the headers, since the possible methods are those names. Here, `method_missing` is an instance method, as each instance will have different contents. A quick doc search revealed the `array.index` method to search through the headers, which I used to index into the row contents. If the CSV was very large, this linear search, an O(n) operation, could prove costly enough that instead generating a hash with the headers as keys and indices as values could be prudent. I chose the simpler option here, however. This then returns the value in the column if the header exists, and raises an error if it doesn't. My only problem when coding was forgetting the difference between symbols and strings, and forgetting the `to_s` method call. 

----------
As my Ruby trip draws to a close, I suppose it's time to answer the important questions: Will I use Ruby again? What lessons are learned?. To be honest, I'm not sure if I'll ever use Ruby. While I liked its ideas, none of them felt like enough of a killer app to begin writing my everyday scripts in it instead of Python, who isn't as flexible but has much easier syntax. I feel like I would need to be doing something fun to want to do Ruby, rather than rushing to finish something as quickly as possible. While `irb` isn't going to become my calculator, I think I'd enjoy making some sort of small site in Rails.\
To me, this journey has taught me to enjoy dynamic langauges more, and to code for composability when possible. I have felt the pendulum of typing preferences swing back towards static typing, with projects like MyPy and TypeScript being incredibly popular. While I still think that large projects benefit from static typing, I think Ruby's duck typing freedom made me appreciate the flexibility that dynamic programming allows, allowing for easy generic programming. I think that my go to languages, while they support function pointers and lambdas, aren't as well equipped to such functional composition as Ruby. However, it's certainly still possible, and after this week, I think I'm going to try to use it more when coding projects. I might also try to switch more from C++ to Rust, since those closures feel even nicer now. 
